package main

import (
	"bytes"
	"database/sql"
	"flag"
	"fmt"
	"log"
	"os"
	"strings"

	_ "github.com/jackc/pgx/stdlib"
)

var oPort = flag.Int("port", 5432, "postgres database port")
var oSchema = flag.String("schema", "information_schema", "the database schema")
var oTable = flag.String("table", "columns", "the database table in that schema")

var columns_query = `
SELECT 	column_name,
		is_nullable,
		data_type,
		ordinal_position,
		numeric_precision
 FROM 	information_schema.columns
WHERE 	table_schema = '%s'
  AND 	table_name   = '%s'
`

type columns struct {
	column_name       string
	is_nullable       string
	data_type         string
	ordinal_position  int
	numeric_precision *int
}

func (c *columns) Scan(r *sql.Rows) error {
	return r.Scan(
		&c.column_name,
		&c.is_nullable,
		&c.data_type,
		&c.ordinal_position,
		&c.numeric_precision)
}

func GoTypeSource(name string, cols []*columns) string {
	b := new(bytes.Buffer)
	fmt.Fprintf(b, "// %s is the exact definition of the equally named Postgres table in schema ?.\n", name)
	fmt.Fprintf(b, "type %s struct {\n", name)
	for i, each := range cols {
		fmt.Fprintf(b, "\t\t%s %s // %d\n", each.column_name, each.GoTypeName(), i+1)
	}
	fmt.Fprintln(b, "}")
	return b.String()
}

func GoScanSource(name string, cols []*columns) string {
	b := new(bytes.Buffer)
	fmt.Fprintf(b, "// Scan reads all the column values from a %s record.\n", name)
	fmt.Fprintf(b, "func (r *%s) Scan(s Scannable) error {\n", name)
	fmt.Fprintf(b, "\treturn s.Scan(\n")
	for i, each := range cols {
		end := ", // %d\n"
		if i == len(cols)-1 {
			end = ") // %d\n"
		}
		fmt.Fprintf(b, "\t\t&r.%s"+end, each.column_name, i+1)
	}
	fmt.Fprintf(b, "}")
	return b.String()
}

func GoSelectSource(name string, cols []*columns) string {
	b := new(bytes.Buffer)
	fmt.Fprintf(b, "/**\nSELECT\t")
	for i, each := range cols {
		prefix := "     ,  "
		if i == 0 {
			prefix = ""
		}
		fmt.Fprintf(b, "%s%s\n", prefix, each.column_name)
	}
	fmt.Fprintf(b, "  FROM\t%s\n", name)
	fmt.Fprint(b, " WHERE\t")
	for i, each := range cols {
		prefix := "   AND\t"
		if i == 0 {
			prefix = ""
		}
		fmt.Fprintf(b, "%s%s = %s\n", prefix, each.column_name, each.column_name)
	}
	fmt.Fprintf(b, "**/")
	return b.String()
}

func GoInsertSource(name string, cols []*columns) string {
	b := new(bytes.Buffer)
	fmt.Fprintf(b, "/**\nINSERT\n  INTO %s (\n", name)
	for i, each := range cols {
		prefix := "     , "
		if i == 0 {
			prefix = "       "
		}
		fmt.Fprintf(b, "%s%s\n", prefix, each.column_name)
	}
	fmt.Fprint(b, ") VALUES (\n")
	for i, each := range cols {
		prefix := "     , "
		if i == 0 {
			prefix = "       "
		}
		fmt.Fprintf(b, "%s$%d", prefix, i+1)
		if i+1 < 10 {
			fmt.Fprint(b, " ")
		}
		fmt.Fprintf(b, " // %s : %s\n", each.column_name, each.data_type)
	}
	fmt.Fprintf(b, ")\n**/")
	return b.String()
}

// GoTypeName return the Go type for a Postgres type. TODO needs a lot more types!
func (c columns) GoTypeName() string {
	switch c.data_type {
	case "integer":
		if "YES" == c.is_nullable {
			return "pgx.NullInt32"
		} else {
			return "int32"
		}
	case "bigint":
		if "YES" == c.is_nullable {
			return "pgx.NullInt64"
		} else {
			return "int64"
		}
	case "character varying":
		if "YES" == c.is_nullable {
			return "pgx.NullString"
		} else {
			return "string"
		}
	case "hstore":
		if "YES" == c.is_nullable {
			return "pgx.NullHstore"
		} else {
			return "pgx.HStore"
		}
	case "timestamp with time zone":
		if "YES" == c.is_nullable {
			return "pgx.NullTime"
		} else {
			return "time.Time"
		}
	case "bytea":
		return "[]byte"
	default:
		return "UNKNOWN:" + c.data_type
	}
}

func main() {
	flag.Parse()
	db, err := sql.Open("pgx", fmt.Sprintf("postgres://boqs:boqs@localhost:%d/boqsdb", *oPort))
	if err != nil {
		log.Fatalf("sql.Open failed: %v ", err)
	}

	rows, err := db.Query(fmt.Sprintf(columns_query, *oSchema, *oTable))
	if err != nil {
		log.Fatalf("db.Query failed: %v ", err)
	}
	defer rows.Close()

	cols := []*columns{}
	for rows.Next() {
		c := new(columns)
		if err := c.Scan(rows); err != nil {
			log.Fatalf("db.Scan failed: %v ", err)
		}
		cols = append(cols, c)
	}

	out := os.Stdout
	fmt.Fprintf(out, `package pg

// generated by genika

import "github.com/jackc/pgx"

`)
	fmt.Fprintln(out, GoTypeSource(*oTable, cols))
	fmt.Fprintln(out, GoScanSource(*oTable, cols))
	fmt.Fprintln(out, GoSelectSource(*oTable, cols))
	fmt.Fprintln(out, GoInsertSource(*oTable, cols))

	if rows.Err() != nil {
		log.Fatalf("db.Query failed: ", rows.Err())
	}

	if err := db.Close(); err != nil {
		log.Fatalf("db.Close unexpectedly failed: %v", err)
	}
}

func padding(word string, length int, separator string) string {
	return word + strings.Repeat(separator, length-len(word))
}
